/// Represents an undefined value. Should never appear in the output of a program.
primitive undef<"share"=1>[WIDTH]() -> (out: WIDTH) {
    assign out = 'x;
}

/// Constants
comb primitive std_const<"share"=1>[WIDTH, VALUE]() -> (out: WIDTH) {
    assign out = VALUE;
}

/// Combinational wire to forward values
comb primitive std_wire<"share"=1>[WIDTH](@data in: WIDTH) -> (out: WIDTH) {
    assign out = in;
}

/// Add two numbers.
comb primitive std_add<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH) {
  assign out = left + right;
}

// Shift operator.
comb primitive std_lsh<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH)
{
  assign out = left << right;
}

/// Primitives
comb primitive std_slice<"share"=1>[IN_WIDTH, OUT_WIDTH](@data in: IN_WIDTH) -> (out: OUT_WIDTH)
{
  assign out = in[OUT_WIDTH-1:0];

  `ifdef VERILATOR
    always_comb begin
      if (IN_WIDTH < OUT_WIDTH)
        $error(
          "std_slice: Input width less than output width\n",
          "IN_WIDTH: %0d", IN_WIDTH,
          "OUT_WIDTH: %0d", OUT_WIDTH
        );
    end
  `endif
}

comb primitive std_bit_slice<"share"=1>[IN_WIDTH, START_IDX, END_IDX, OUT_WIDTH](@data in: IN_WIDTH) -> (out: OUT_WIDTH)
{
    assign out = in[END_IDX:START_IDX];

  `ifdef VERILATOR
    always_comb begin
      if (START_IDX < 0 || END_IDX > IN_WIDTH-1)
        $error(
          "std_bit_slice: Slice range out of bounds\n",
          "IN_WIDTH: %0d", IN_WIDTH,
          "START_IDX: %0d", START_IDX,
          "END_IDX: %0d", END_IDX,
        );
    end
  `endif
}

/// Logical Operators
comb primitive std_not<"share"=1>[WIDTH](@data in: WIDTH) -> (out: WIDTH)
{
  assign out = ~in;
}
comb primitive std_and<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH)
{
  assign out = left & right;
}
comb primitive std_or<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH)
{
  assign out = left | right;
}
comb primitive std_xor<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH)
{
  assign out = left ^ right;
}

/// Numerical Operators
comb primitive std_sub<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH)
{
  assign out = left - right;
}
comb primitive std_gt<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1)
{
  assign out = left > right;
}
comb primitive std_lt<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1)
{
  assign out = left < right;
}
comb primitive std_eq<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1)
{
  assign out = left == right;
}
comb primitive std_neq<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1)
{
  assign out = left != right;
}
comb primitive std_ge<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1)
{
  assign out = left >= right;
}
comb primitive std_le<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: 1)
{
  assign out = left <= right;
}
comb primitive std_rsh<"share"=1>[WIDTH](@data left: WIDTH, @data right: WIDTH) -> (out: WIDTH)
{
  assign out = left >> right;
}
comb primitive std_mux<"share"=1>[WIDTH](@data cond: 1, @data tru: WIDTH, @data fal: WIDTH) -> (out: WIDTH)
{
  assign out = cond ? tru : fal;
}

/// Standard register with a one-cycle latency.
// ANCHOR: std_reg_def
primitive std_reg<"state_share"=1>[WIDTH](
  @write_together(1) @data in: WIDTH,
  @write_together(1) @interval(1) @go write_en: 1,
  @clk clk: 1,
  @reset reset: 1
) -> (
  @stable @data out: WIDTH,
  @done done: 1
)
// ANCHOR_END: std_reg_def
{
  always_ff @(posedge clk) begin
    if (reset) begin
       out <= 0;
       done <= 0;
    end else if (write_en) begin
      out <= in;
      done <= 1'd1;
    end else done <= 1'd0;
  end
}

/// Standard register with a one-cycle latency. Only difference with std_reg
// is that starts at 1 rather than 0. This helps with one-hot encoding.
primitive init_one_reg<"state_share"=1>[WIDTH](
  @write_together(1) @data in: WIDTH,
  @write_together(1) @interval(1) @go write_en: 1,
  @clk clk: 1,
  @reset reset: 1
) -> (
  @stable out: WIDTH,
  @done done: 1
)
{
  always_ff @(posedge clk) begin
    if (reset) begin
       out <= 1;
       done <= 0;
    end else if (write_en) begin
      out <= in;
      done <= 1'd1;
    end else done <= 1'd0;
  end
}

  // Skid Buffers
  primitive std_skid_buffer<"share"=1>[WIDTH](
    @data in: WIDTH,
    i_valid : 1,
    i_ready : 1,
    @clk clk: 1,
    @reset reset: 1
  ) -> (
    @stable out: WIDTH,
    o_valid : 1,
    o_ready : 1
  )
  {

  logic [WIDTH-1:0] val;
  logic bypass_rg;
  always @(posedge clk) begin
    // Reset  
    if (reset) begin      
      // Internal Registers
      val <= '0;     
      bypass_rg <= 1'b1;
    end   
    // Out of reset
    else begin      
      // Bypass state      
      if (bypass_rg) begin         
        if (!i_ready && i_valid) begin
          val <= in;          // Data skid happened, store to buffer
          bypass_rg <= 1'b0;  // To skid mode  
        end 
      end 
      // Skid state
      else begin         
        if (i_ready) begin
          bypass_rg <= 1'b1;  // Back to bypass mode           
        end
      end
    end
  end

  assign o_ready = bypass_rg;
  assign out = bypass_rg ? in : val;
  assign o_valid = bypass_rg ? i_valid : 1'b1;
  }

  // Bypass Register
  primitive std_bypass_reg<"share"=1>[WIDTH](
    @data in: WIDTH,
    @go write_en: 1,
    @clk clk: 1,
    @reset reset: 1
  ) -> (
    @stable out: WIDTH,
    @done done: 1
  )
  {
  logic [WIDTH-1:0] val;
  assign out = write_en ? in : val;

  always_ff @(posedge clk) begin
    if (reset) begin
      val <= 0;
      done <= 0;
    end else if (write_en) begin
      val <= in;
      done <= 1'd1;
    end else done <= 1'd0;
  end
  }